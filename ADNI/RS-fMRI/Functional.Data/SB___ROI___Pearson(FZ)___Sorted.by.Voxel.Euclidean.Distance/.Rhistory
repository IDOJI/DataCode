Best_Fit = ordinalNet(x = Logistic$Train_X %>% as.matrix,,
y = Logistic$Train_y %>% unlist,
alpha = Best_alpha,
standardize = FALSE,
family = Logistic$Family,
link = Logistic$Link)
#=============================================================================
# Inserting best
#=============================================================================
# if(which.min(Best_Fit_Summary$aic) == which.min(Best_Fit_Summary$bic)){
#   best_lambda = Best_Fit$lambdaVals[which.min(Best_Fit_Summary$aic)]
# }else{
#   stop("Best indice of AIC and BIC are different!")
# }
# Results summary
Best_Fit_Summary = summary(Best_Fit)
# 초기 사용자 입력 변수 선언
user_input_n = ""
while(TRUE) {
print(Best_Fit_Summary)
# 사용자 입력 받기
user_input_n <- readline(prompt="Which model is best? Input the number of row: ")
# 입력값이 숫자로만 구성되었는지 확인
if(grepl("^[0-9]+$", user_input_n)) {
line_number <- as.numeric(user_input_n)
# 입력된 값이 유효한 행 번호인지 확인
if(line_number > 0 && line_number <= nrow(Best_Fit_Summary)) {
Best_lambda = Best_Fit_Summary[line_number, "lambdaVals"]
print(paste("The selected best lambda is:", Best_lambda))
break # 유효한 입력이므로 while 루프 종료
} else {
print("잘못된 라인 번호입니다. 다시 입력해주세요.")
}
} else {
print("유효한 숫자를 입력해주세요.")
}
}
Best_lambda
#=============================================================================
# Combine Resulst
#=============================================================================
Logistic$Best_Model = Best_Fit_Final
Logistic$Best_alpha = Best_alpha
#=============================================================================
# Fit again using best parameters
#=============================================================================
Best_Fit_Final = ordinalNet(x = Logistic$Train_X %>% as.matrix,,
y = Logistic$Train_y %>% unlist,
lambdaVals = Best_lambda,
alpha = Best_alpha,
standardize = FALSE,
family = Logistic$Family,
link = Logistic$Link)
#=============================================================================
# Combine Resulst
#=============================================================================
Logistic$Best_Model = Best_Fit_Final
Logistic$Best_alpha = Best_alpha
#=============================================================================
# Extract results and prediction & Exporting
#=============================================================================
Results.list = Classification___Logistic___Results(Logistic)
#=============================================================================
# Extracting Results
#=============================================================================
Logistic$Best_Model_Coef = Classification___Logistic___Results___Coefficients(Logistic$Best_Model)
Logistic$Best_Model_Coef
!is.null(Logistic$Plot_x_varname)
#=============================================================================
# Cumulative Probability plot for most effective variable
#=============================================================================
if(!is.null(Logistic$Plot_x_varname)){
Logistic$Cumulative_plot = Classification___Logistic___Results___Cumulative.Probability.Plot(Logistic)
}else{
Logistic$Cumulative_plot = NULL
}
#=============================================================================
# Prediction
#=============================================================================
Logistic$Prediction = Classification___Logistic___Results___Predict(Logistic)
#===========================================================================
# Arguments
#===========================================================================
fit = Logistic$Best_Model
X_Test = Logistic$Test_X
y_Test = Logistic$Test_y
x_varname = Logistic$Plot_x_varname
y_varname = Logistic$Plot_y_varname
AUC_in_Legend = Logistic$AUC_in_Legend
path_Export = Logistic$path_Export
#===========================================================================
# Prediction
#===========================================================================
# Predicted Probabilities
newdata = X_Test %>% as_tibble %>% dplyr::select(all_of(x_varname))
if(class(fit)=="ordinalNet"){
Predicted_Probs = predict(fit, newx = X_Test %>% as.matrix, type = "response") # Ordinal_Elastic인 경우에는 잘 동작함.
}else{
Predicted_Probs = predict(fit, newdata = X_Test, type = "probs")
}
# Get the predicted classes from the probabilities
Predicted_Classes = apply(Predicted_Probs, 1, which.max) %>% unname
#===========================================================================
# Compare the classification & Extract the misclassified subjects
#===========================================================================
y_Test_unlist = y_Test %>% unlist()
y_Test_New = y_Test_unlist %>% as.integer()
Index_Misclassified = which(Predicted_Classes != y_Test_New)
Misclassified.df = cbind(Group = as.character(y_Test_unlist[Index_Misclassified]),
Predicted_Class = levels(y_Test)[Predicted_Classes[Index_Misclassified]],
X_Test[Index_Misclassified, ] %>% as.data.frame,
Index = Index_Misclassified)
Misclassified.df = cbind(Group = as.character(y_Test_unlist[Index_Misclassified]),
Predicted_Class = levels(y_Test)[Predicted_Classes[Index_Misclassified]],
X_Test[Index_Misclassified, ] %>% as.data.frame,
Index = Index_Misclassified)
as.character(y_Test_unlist[Index_Misclassified])
levels(y_Test)[Predicted_Classes[Index_Misclassified]]
levels(y_Test)
y_Test
unlist(y_Test)
Misclassified.df = cbind(Group = as.character(y_Test_unlist[Index_Misclassified]),
Predicted_Class = levels(unlist(y_Test))[Predicted_Classes[Index_Misclassified]],
X_Test[Index_Misclassified, ] %>% as.data.frame,
Index = Index_Misclassified)
#=============================================================================
# Prediction
#=============================================================================
Logistic$Prediction = Classification___Logistic___Results___Predict(Logistic)
Classification___Logistic___Results___Predict = function(Logistic){
#===========================================================================
# Arguments
#===========================================================================
fit = Logistic$Best_Model
X_Test = Logistic$Test_X
y_Test = Logistic$Test_y
x_varname = Logistic$Plot_x_varname
y_varname = Logistic$Plot_y_varname
AUC_in_Legend = Logistic$AUC_in_Legend
path_Export = Logistic$path_Export
#===========================================================================
# Prediction
#===========================================================================
# Predicted Probabilities
newdata = X_Test %>% as_tibble %>% dplyr::select(all_of(x_varname))
if(class(fit)=="ordinalNet"){
Predicted_Probs = predict(fit, newx = X_Test %>% as.matrix, type = "response") # Ordinal_Elastic인 경우에는 잘 동작함.
}else{
Predicted_Probs = predict(fit, newdata = X_Test, type = "probs")
}
# Get the predicted classes from the probabilities
Predicted_Classes = apply(Predicted_Probs, 1, which.max) %>% unname
#===========================================================================
# Compare the classification & Extract the misclassified subjects
#===========================================================================
y_Test_unlist = y_Test %>% unlist()
y_Test_New = y_Test_unlist %>% as.integer()
Index_Misclassified = which(Predicted_Classes != y_Test_New)
Misclassified.df = cbind(Group = as.character(y_Test_unlist[Index_Misclassified]),
Predicted_Class = levels(unlist(y_Test))[Predicted_Classes[Index_Misclassified]],
X_Test[Index_Misclassified, ] %>% as.data.frame,
Index = Index_Misclassified)
#===========================================================================
# Confusion matrix
#===========================================================================
# Create a confusion matrix
Confusion_matrix = table(Predicted = Predicted_Classes, Actual = y_Test_unlist)
if(nrow(Confusion_matrix) != levels(y_Test_unlist) %>% length){
rows_not_defined = unique(as.integer(y_Test_unlist))[! y_Test %>% as.integer %>% unique %in% rownames(Confusion_matrix)] %>% sort
New_matrix = matrix(0, nrow = rows_not_defined %>% length, ncol = y_Test_unlist %>% unique %>% length)
rownames(New_matrix) = rows_not_defined
Combined_Matrix = rbind(New_matrix, Confusion_matrix)
row_names = rownames(Combined_Matrix)
Confusion_matrix = Combined_Matrix[row_names %>% as.numeric %>% order,]
}
rownames(Confusion_matrix) = levels(y_Test_unlist)
# Calculate the number of correct predictions (diagonal of the confusion matrix)
Correct_predictions = sum(diag(Confusion_matrix))
# Calculate the total number of predictions (sum of all elements in the confusion matrix)
Total_predictions = sum(Confusion_matrix)
# Calculate the misclassification rate
Misclassification_rate = 1 - (Correct_predictions / Total_predictions)
#===========================================================================
# ROAUC
#===========================================================================
ROAUC.list = Classification___Logistic___Results___Predict___AUROC(Predicted_Probs, y_Test_unlist, AUC_in_Legend, path_Export) %>% suppressWarnings()
#===========================================================================
# return
#===========================================================================
c(list(Confusion_Matrix = Confusion_matrix, Misclassification_Rate = Misclassification_rate, Misclassified_Subjects = Misclassified.df), ROAUC.list) %>% return()
}
#=============================================================================
# Prediction
#=============================================================================
Logistic$Prediction = Classification___Logistic___Results___Predict(Logistic)
#=============================================================================
# Export results
#=============================================================================
Classification___Logistic___Results___Export(Logistic)
rm(list=ls())
path_OS = "C:/Users/lleii/"
#=============================================================================================
# Mac
#=============================================================================================
# path_OS = "/Users/Ido/"
# path_External.Drive = "/Volumes/Seagate/"
#============================================================================================
# Windows
#============================================================================================
# path_OS = "C:/Users/lleii/"
#============================================================================================
require(tidyverse)
require(dplyr)
require(pROC)
require(ggplot2)
require(clipr)
require(ggstatsplot)
list.files(paste0(path_OS, "Dropbox/Github/Rpkgs/ADNIprep/R"), full.names = T) %>% walk(source)
list.files(paste0(path_OS, "Dropbox/Github/Rpkgs/StatsR/R"), full.names = T) %>% walk(source)
list.files(paste0(path_OS, "Dropbox/Github/Rpkgs/refineR/R"), full.names = T) %>% walk(source)
#===============================================================================
# Path
#===============================================================================
path_Paper = paste0(path_OS, "Dropbox/Github/Papers/MS")
path_Results = paste0(path_Paper, "/Results")
fs::dir_create(path_Results, recurse = TRUE)
path_Data = list.files(path_Paper, pattern = "Data", full.names = T)
path_Data = list.files(path_Data, pattern = "\\.rds$", full.names = T)
Data_Names = path_Data %>% basename() %>% tools::file_path_sans_ext()
#===============================================================================
# Loading Data
#===============================================================================
Data.list = lapply(path_Data, readRDS) %>% setNames(Data_Names)
#===============================================================================
# Logistic setting
#===============================================================================
names(Data.list)
Logistic_Setting = function(ith_Data, path_Export){
# ith_Data = Data.list[[1]]
Logistic = list(#----------------------------------------
# Data Setting
#----------------------------------------
Train_X = ith_Data$X_Train,
Train_y = ith_Data$y_Train,
Test_X = ith_Data$X_Test,
Test_y = ith_Data$y_Test,
# Train_Folds_Index.vec = ith_Data$X_Train_CV_Ind,
Train_Folds_Index.list = ith_Data$Train_Fold_Index.list,
Standardize = TRUE,
#----------------------------------------
# Modeling Fitting
#----------------------------------------
# Method
Response_Type = "Ordinal",
Fitting_Method = "ElasticNet", #
# Model
Family = c("cumulative"),
Link = c("logit"),
# Penalty
penalty_alpha = seq(0, 1, 0.5),
penalty_lambda = exp(seq(-2,2,0.01)),
#----------------------------------------
# Tuning measures
#----------------------------------------
Tune_Method = c("cvMisclass"),
# Best_Model_Criterion = c(#Classification___Logistic___Ordinal___Elastic___NonGroupedPenalty
#                          "cvLoglik", "cvMisclass", "cvBrier", "cvDevPct", "aic", "bic"),
#----------------------------------------
# Grouping variables
#----------------------------------------
Grouped_Vars_Index = NULL, # NULL이 아니면 그룹 정보를 사용, 그룹 위치 벡터를 넣어야 함.
#----------------------------------------
# Plotting
#----------------------------------------
Plot_y_varname = NULL, # proportional logit plot은 하나의 변수만 가능하므로 한 변수 지정
Plot_x_varname = NULL, # 지정하지 않으면 plot 안 그려짐
AUC_in_Legend = TRUE,
#----------------------------------------
# Export Results
#----------------------------------------
path_Export = path_Export)
return(Logistic)
}
Logistic_Setting = function(ith_Data, path_Export){
# ith_Data = Data.list[[1]]
Logistic = list(#----------------------------------------
# Data Setting
#----------------------------------------
Train_X = ith_Data$X_Train,
Train_y = ith_Data$y_Train,
Test_X = ith_Data$X_Test,
Test_y = ith_Data$y_Test,
# Train_Folds_Index.vec = ith_Data$X_Train_CV_Ind,
Train_Folds_Index.list = ith_Data$Train_Fold_Index.list,
Standardize = TRUE,
#----------------------------------------
# Modeling Fitting
#----------------------------------------
# Method
Response_Type = "Ordinal",
Fitting_Method = "ElasticNet", #
# Model
Family = c("cumulative"),
Link = c("logit"),
# Penalty
penalty_alpha = seq(0, 1, 0.1),
penalty_lambda = exp(seq(-2,2,0.01)),
#----------------------------------------
# Tuning measures
#----------------------------------------
Tune_Method = c("cvMisclass"),
# Best_Model_Criterion = c(#Classification___Logistic___Ordinal___Elastic___NonGroupedPenalty
#                          "cvLoglik", "cvMisclass", "cvBrier", "cvDevPct", "aic", "bic"),
#----------------------------------------
# Grouping variables
#----------------------------------------
Grouped_Vars_Index = NULL, # NULL이 아니면 그룹 정보를 사용, 그룹 위치 벡터를 넣어야 함.
#----------------------------------------
# Plotting
#----------------------------------------
Plot_y_varname = NULL, # proportional logit plot은 하나의 변수만 가능하므로 한 변수 지정
Plot_x_varname = NULL, # 지정하지 않으면 plot 안 그려짐
AUC_in_Legend = TRUE,
#----------------------------------------
# Export Results
#----------------------------------------
path_Export = path_Export)
return(Logistic)
}
Logistic_Setting = function(ith_Data, path_Export){
# ith_Data = Data.list[[1]]
Logistic = list(#----------------------------------------
# Data Setting
#----------------------------------------
Train_X = ith_Data$X_Train,
Train_y = ith_Data$y_Train,
Test_X = ith_Data$X_Test,
Test_y = ith_Data$y_Test,
# Train_Folds_Index.vec = ith_Data$X_Train_CV_Ind,
Train_Folds_Index.list = ith_Data$Train_Fold_Index.list,
Standardize = TRUE,
#----------------------------------------
# Modeling Fitting
#----------------------------------------
# Method
Response_Type = "Ordinal",
Fitting_Method = "ElasticNet", #
# Model
Family = c("cumulative"),
Link = c("logit"),
# Penalty
penalty_alpha = seq(0, 1, 0.01),
penalty_lambda = exp(seq(-2,2,0.01)),
#----------------------------------------
# Tuning measures
#----------------------------------------
Tune_Method = c("cvMisclass"),
# Best_Model_Criterion = c(#Classification___Logistic___Ordinal___Elastic___NonGroupedPenalty
#                          "cvLoglik", "cvMisclass", "cvBrier", "cvDevPct", "aic", "bic"),
#----------------------------------------
# Grouping variables
#----------------------------------------
Grouped_Vars_Index = NULL, # NULL이 아니면 그룹 정보를 사용, 그룹 위치 벡터를 넣어야 함.
#----------------------------------------
# Plotting
#----------------------------------------
Plot_y_varname = NULL, # proportional logit plot은 하나의 변수만 가능하므로 한 변수 지정
Plot_x_varname = NULL, # 지정하지 않으면 plot 안 그려짐
AUC_in_Legend = TRUE,
#----------------------------------------
# Export Results
#----------------------------------------
path_Export = path_Export)
return(Logistic)
}
Logistic_Setting = function(ith_Data, path_Export){
# ith_Data = Data.list[[1]]
Logistic = list(#----------------------------------------
# Data Setting
#----------------------------------------
Train_X = ith_Data$X_Train,
Train_y = ith_Data$y_Train,
Test_X = ith_Data$X_Test,
Test_y = ith_Data$y_Test,
# Train_Folds_Index.vec = ith_Data$X_Train_CV_Ind,
Train_Folds_Index.list = ith_Data$Train_Fold_Index.list,
Standardize = TRUE,
#----------------------------------------
# Modeling Fitting
#----------------------------------------
# Method
Response_Type = "Ordinal",
Fitting_Method = "ElasticNet", #
# Model
Family = c("cumulative"),
Link = c("logit"),
# Penalty
penalty_alpha = seq(0, 1, 0.1),
penalty_lambda = exp(seq(-2,2,0.01)),
#----------------------------------------
# Tuning measures
#----------------------------------------
Tune_Method = c("cvMisclass"),
# Best_Model_Criterion = c(#Classification___Logistic___Ordinal___Elastic___NonGroupedPenalty
#                          "cvLoglik", "cvMisclass", "cvBrier", "cvDevPct", "aic", "bic"),
#----------------------------------------
# Grouping variables
#----------------------------------------
Grouped_Vars_Index = NULL, # NULL이 아니면 그룹 정보를 사용, 그룹 위치 벡터를 넣어야 함.
#----------------------------------------
# Plotting
#----------------------------------------
Plot_y_varname = NULL, # proportional logit plot은 하나의 변수만 가능하므로 한 변수 지정
Plot_x_varname = NULL, # 지정하지 않으면 plot 안 그려짐
AUC_in_Legend = TRUE,
#----------------------------------------
# Export Results
#----------------------------------------
path_Export = path_Export)
return(Logistic)
}
i=1
names(Data.list)[1]
names(Data.list)
#===============================================================================
# Classification
#===============================================================================
Results.list = lapply(seq_along(Data.list)[1:2], function(i){
ith_Data.list = Data.list[[i]]
ith_Results = Classification(Logistic = Logistic_Setting(ith_Data.list, path_Results))
return(ith_Results)
})
paste0(path_Results, "/", names(Data.list)[i])
#===============================================================================
# Classification
#===============================================================================
Results.list = lapply(seq_along(Data.list)[1:2], function(i){
ith_Data.list = Data.list[[i]]
ith_Results = Classification(Logistic = Logistic_Setting(ith_Data.list, paste0(path_Results, "/", names(Data.list)[i])))
return(ith_Results)
})
#===============================================================================
# Classification
#===============================================================================
Results.list = lapply(seq_along(Data.list)[1], function(i){
ith_Data.list = Data.list[[i]]
ith_Results = Classification(Logistic = Logistic_Setting(ith_Data.list, paste0(path_Results, "/", names(Data.list)[i])))
return(ith_Results)
})
fda::pca.fd()
fda::pca.fd
?fda::pca.fd
?inprod
?fda::inprod
fda::inprod
rm(list=ls())
path_OS = "C:/Users/lleii/"
# rm(list=ls())
#=============================================================================================
# Mac
#=============================================================================================
# path_OS = "/Users/Ido/"
#============================================================================================
# Windows
#============================================================================================
# path_OS = "C:/Users/lleii/"
#============================================================================================
require(tidyverse)
require(dplyr)
require(clipr)
require(fda)
list.files(paste0(path_OS, "Dropbox/Github/Rpkgs/ADNIprep/R"), full.names = T) %>% walk(source)
list.files(paste0(path_OS, "Dropbox/Github/Rpkgs/StatsR/R"), full.names = T) %>% walk(source)
list.files(paste0(path_OS, "Dropbox/Github/Rpkgs/refineR/R"), full.names = T) %>% walk(source)
#===============================================================================
# Path
#===============================================================================
path_Data_SB_FDA = paste0(path_OS, "Dropbox/Data/ADNI___RS.fMRI___SB___Functional.Data")
path_Data_SB_FDA_Euclidean = list.files(path_Data_SB_FDA, full.names = T, pattern = "Euclidean")
path_Data_SB_FDA_Euclidean_Smoothing = list.files(path_Data_SB_FDA_Euclidean, full.names=T, pattern = "Smoothing") %>% list.files(full.names=T, pattern = "\\.rds$")
path_Data_SB_FDA_Euclidean__FPCA = paste0(path_Data_SB_FDA_Euclidean, "/FPCA")
path_Data_SB_FDA_Euclidean__FPCA_Scores = paste0(path_Data_SB_FDA_Euclidean, "/FPCA_Scores_With_Group_Nums")
#===============================================================================
# Loading smoothing Data
#===============================================================================
Smoothing.list = lapply(path_Data_SB_FDA_Euclidean_Smoothing, readRDS) %>% setNames( basename(path_Data_SB_FDA_Euclidean_Smoothing) %>% tools::file_path_sans_ext())
Smoothing.list %>% length
#===============================================================================
# Path
#===============================================================================
path_Data = paste0(path_OS, "Dropbox/Data")
path_Data_FDA = list.files(path_Data, pattern = "fda")
path_Data_FDA
)
path_Data_FDA = list.files(path_Data, pattern = "fda", ignore.case = T, full.names=T)
path_Data_FDA
#===============================================================================
# Path
#===============================================================================
path_Data = paste0(path_OS, "Dropbox/Data")
list.files(path_Data)
path_Data_FDA = list.files(path_Data, pattern = "Functional.Data", ignore.case = T, full.names=T)
path_Data_FDA
path_Data_FDA_Euclidean = list.files(path_Data_SB_FDA, full.names = T, pattern = "Euclidean")
path_Data_FDA_Euclidean
list.files(path_Data_SB_FDA, full.names = T)
list.files(path_Data_FDA, full.names = T)
path_Data_FDA_Euclidean = list.files(path_Data_FDA, full.names = T, pattern = "Euclidean")
path_Data_FDA_Euclidean
path_Data_FDA_Euclidean_Smoothing = list.files(path_Data_FDA_Euclidean, full.names=T, pattern = "Smoothing") %>% list.files(full.names=T, pattern = "\\.rds$")
path_Data_FDA_Euclidean_Smoothing
path_Data_FDA_Euclidean__Smoothing = list.files(path_Data_FDA_Euclidean, full.names=T, pattern = "Smoothing") %>% list.files(full.names=T, pattern = "\\.rds$")
